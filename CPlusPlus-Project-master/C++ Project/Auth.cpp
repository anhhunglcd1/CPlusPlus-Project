#include "login_system.h"
#include <iostream>
#include <limits>
#include <fstream>
#include <sstream>
#include <string>
using namespace std;

// Tìm user theo username trong danh sách users
// Trả về con trỏ tới User nếu tìm thấy, nullptr nếu không
User* findUser(vector<User>& users, const string& username) {
    for (auto& u : users)
        if (u.username == username) return &u;
    return nullptr;
}

// Đăng ký người dùng mới (do user tự đăng ký hoặc admin tạo hộ)
// Input: danh sách users, cờ byAdmin
// Output: true nếu đăng ký thành công, false nếu tên đã tồn tại
bool registerUser(vector<User>& users, bool byAdmin) {
    string username, fullName, pwd;
    cout << "Username: ";
    cin >> username;
    if (findUser(users, username)) {
        cout << "Username already exists.\n";
        return false;
    }
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    cout << "Full name: ";
    getline(cin, fullName);

    bool autoGen = false;
    if (!byAdmin) {
        cout << "Password (leave blank to auto-generate): ";
        pwd = inputHiddenPassword();
        if (pwd.empty()) {
            pwd = genRandomPassword(8);
            autoGen = true;
            cout << "Generated password: " << pwd << "\n";
        }
    }
    else {
        pwd = "12345678";
        cout << "Default password \"12345678\" assigned.\n";
    }

    User u;
    u.username = username;
    u.passwordHash = hashPassword(pwd);
    u.fullName = fullName;
    u.isAdmin = byAdmin;
    u.isAutoGenerated = autoGen;
    u.wallet.id = "WAL" + to_string(time(nullptr));
    u.wallet.balance = 0;
    u.wallet.poolBalance = 0;    // KHỞI TẠO ban đầu
    u.otp.clear();
    u.pendingFullName.clear();
    u.pendingPasswordHash.clear();

    // Cấp 5 điểm thưởng nếu rewardPool >= 5
    if (rewardPool >= 5) {
        u.wallet.balance += 5;
        u.wallet.poolBalance += 5;     // *** CHỈNH SỬA: thêm tracking poolBalance ***
        rewardPool -= 5;
        saveRewardPool(rewardPool);
    }

    users.push_back(u);
    saveUsers(users);
    cout << "User '" << username << "' registered successfully.\n";
    return true;
}


// Xóa user khỏi danh sách theo username, đồng thời lưu lại file
// Trả về true nếu xóa thành công, false nếu không tìm thấy user
bool deleteUser(vector<User>& users, const string& username) {
    for (auto it = users.begin(); it != users.end(); ++it) {
        if (it->username == username) {
            if (it->isAdmin) {
                cout << "Cannot delete admin.\n";
                return false;
            }
            // === CHỈNH SỬA: chỉ hoàn trả phần poolBalance còn lại ===
            if (it->wallet.poolBalance > 0) {
                rewardPool += it->wallet.poolBalance;
                saveRewardPool(rewardPool);
            }
            // === END CHỈNH SỬA ===

            users.erase(it);
            saveUsers(users);
            cout << "Deleted user \"" << username << "\".\n";
            return true;
        }
    }
    return false;
}

// Yêu cầu nhập OTP để xác nhận thao tác quan trọng (chuyển điểm, đổi thông tin...)
// Sinh OTP ngẫu nhiên, in ra màn hình, kiểm tra input từ người dùng
bool requireOTP(const string& username) {
    string otp = genOTP(); // Tạo OTP ngẫu nhiên
    cout << "[OTP for " << username << ": " << otp << "]\n";
    cout << "Enter OTP: ";
    string in; cin >> in;
    if (in != otp) {
        cout << "Invalid OTP.\n";
        return false;
    }
    return true;
}

// Xóa block OTP đã xác nhận thành công khỏi file pending_change.txt
// (Chỉ thực hiện khi người dùng xác nhận OTP đổi tên/mật khẩu)
void removePendingChange(const string& username, const string& otp) {
    ifstream fin("pending_change.txt");
    if (!fin) return;
    ostringstream oss;
    string line, block;
    bool found = false, inBlock = false;

    // Đọc từng dòng file, tìm đúng block có username và otp cần xóa
    while (getline(fin, line)) {
        if (line.find("Username: ") == 0) {
            if (!block.empty() && !found) oss << block; // Ghi lại các block không trùng
            block.clear();
            found = false;
            inBlock = false;
        }
        block += line + "\n";
        if (line == "Username: " + username) inBlock = true;
        if (inBlock && line == "OTP: " + otp) found = true;
        if (line == "-----------") {
            if (!found) oss << block;
            block.clear();
            found = false;
            inBlock = false;
        }
    }
    if (!block.empty() && !found) oss << block;
    fin.close();

    // Ghi lại file đã xóa block vừa xác nhận
    ofstream fout("pending_change.txt", ios::trunc);
    fout << oss.str();
    fout.close();
}

// Hàm đăng nhập hệ thống
// Nếu user có pending change (đổi tên hoặc mật khẩu do admin thao tác hộ), yêu cầu nhập OTP để xác nhận
// Nếu không có pending change, đăng nhập bình thường bằng mật khẩu
User* login(vector<User>& users) {
    string username;
    cout << "Username: ";
    getline(cin, username);
    if (username.empty()) getline(cin, username); // Đảm bảo không bỏ qua input nếu trống
    User* u = findUser(users, username);
    if (!u) { cout << "User not found.\n"; return nullptr; }

    // Nếu user thường (không phải admin) và đang có pending change (đổi tên hoặc mật khẩu), yêu cầu nhập OTP
    if (!u->isAdmin && !u->otp.empty() &&
        (!u->pendingFullName.empty() || !u->pendingPasswordHash.empty())) {

        cout << "Pending update detected!\n";
        // Hiển thị chi tiết thông tin sẽ được thay đổi sau khi xác nhận OTP
        if (!u->pendingFullName.empty()) {
            cout << "- Your full name will be changed to: " << u->pendingFullName << endl;
        }
        if (!u->pendingPasswordHash.empty()) {
            cout << "- Your password will be changed (new password set by admin)" << endl;
        }
        cout << "Your OTP is: " << u->otp << endl;
        cout << "Enter OTP to confirm these changes: ";
        string in; cin >> in;
        if (in == u->otp) {
            // Nếu nhập đúng OTP, cập nhật thông tin và xóa trạng thái chờ xác nhận
            if (!u->pendingFullName.empty()) {
                u->fullName = u->pendingFullName;
                u->pendingFullName.clear();
            }
            if (!u->pendingPasswordHash.empty()) {
                u->passwordHash = stoull(u->pendingPasswordHash); // chuyển string -> số
                u->pendingPasswordHash.clear();
            }
            removePendingChange(u->username, u->otp); // Xóa block đã xác nhận khỏi file
            u->otp.clear();
            saveUsers(users);
            cout << "Changes applied. Please login again.\n";
        }
        else {
            cout << "Invalid OTP. Changes not applied.\n";
        }
        return nullptr; // Đăng xuất để đăng nhập lại sau khi xác nhận
    }

    // Đăng nhập bình thường bằng mật khẩu
    cout << "Password: ";
    string pwd = inputHiddenPassword();
    if (u->passwordHash != hashPassword(pwd)) {
        cout << "Login failed.\n";
        return nullptr;
    }
    // Nếu mật khẩu đang là tự sinh, bắt buộc đổi sang mật khẩu mới
    if (u->isAutoGenerated) {
        cout << "\nYour password was auto-generated. You must change it now.\n";
        while (true) {
            cout << "New password: "; string np = inputHiddenPassword();
            cout << "Confirm: "; string cp = inputHiddenPassword();
            if (np != cp) cout << "Passwords do not match. Try again.\n";
            else if (np.empty()) cout << "Password cannot be empty.\n";
            else {
                u->passwordHash = hashPassword(np);
                u->isAutoGenerated = false;
                saveUsers(users);
                cout << "Password changed successfully.\n";
                break;
            }
        }
    }
    cout << "Welcome, " << u->fullName << (u->isAdmin ? " (Admin)" : "") << "!\n";
    cout << "\nPress Enter to main menu...";
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    return u;
}
