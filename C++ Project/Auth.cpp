#include "login_system.h"                      // Bao gồm file header định nghĩa các hàm/cấu trúc liên quan
#include <iostream>                            // Thư viện vào/ra chuẩn
#include <limits>                              // Để dùng numeric_limits xử lý buffer nhập
#include <fstream>                             // Xử lý file
#include <sstream>                             // Chuỗi luồng (dùng khi thao tác file block)
#include <string>                              // Chuỗi ký tự
using namespace std;                           // Dùng tên chuẩn trong C++ cho ngắn

// =======================
// Tìm user theo username
// =======================
// Trả về: con trỏ User nếu tìm thấy, nullptr nếu không tìm thấy
User* findUser(vector<User>& users, const string& username) {
    for (auto& u : users)                      // Duyệt từng phần tử (User) trong vector users
        if (u.username == username)            // So sánh username cần tìm với username từng user
            return &u;                         // Nếu trùng, trả về con trỏ tới user này
    return nullptr;                            // Không tìm thấy, trả về nullptr
}

// ========================
// Đăng ký người dùng mới
// ========================
// users: danh sách user, byAdmin: true nếu admin tạo hộ, false nếu user tự đăng ký
// Trả về: true nếu đăng ký thành công, false nếu bị trùng username
bool registerUser(vector<User>& users, bool byAdmin) {
    string username, fullName, pwd;

    // ===== Vòng lặp nhập username: bắt buộc không trùng và không để trống =====
    while (true) {
        cout << "Username: ";
        cin >> username; // Nhập username (không có dấu cách)
        if (username.empty()) { // Kiểm tra để trống
            cout << "Username cannot be empty! Please enter again.\n";
            continue;
        }
        if (findUser(users, username)) { // Kiểm tra trùng username trong danh sách
            cout << "Username already exists. Please enter a different username.\n";
            continue;
        }
        break; // Hợp lệ thì thoát vòng lặp
    }

    cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Xóa kí tự thừa trước khi nhập tên (tránh lỗi khi dùng getline)

    // ===== Vòng lặp nhập họ tên: bắt buộc không để trống =====
    while (true) {
        cout << "Full name: ";
        getline(cin, fullName); // Nhập fullName (có thể có dấu cách)
        if (fullName.empty()) { // Kiểm tra để trống
            cout << "Full name cannot be empty! Please enter again.\n";
            continue;
        }
        break; // Hợp lệ thì thoát vòng lặp
    }

    // ===== Xử lý nhập mật khẩu: có thể để trống (sẽ tự sinh) =====
    bool autoGen = false; // Ghi nhận có phải tự sinh mật khẩu không
    if (!byAdmin) { // Người dùng tự đăng ký
        cout << "Password (leave blank to auto-generate): ";
        pwd = inputHiddenPassword(); // Nhập mật khẩu (hiện dấu *)
        if (pwd.empty()) { // Nếu để trống thì tự sinh mật khẩu ngẫu nhiên
            pwd = genRandomPassword(8);
            autoGen = true;
            cout << "Generated password: " << pwd << "\n"; // Báo mật khẩu cho user
        }
    }
    else { // Admin tạo hộ
        pwd = "12345678"; // Mật khẩu mặc định cho user mới tạo bởi admin
        cout << "Default password \"12345678\" assigned.\n";
    }

    // ===== Khởi tạo user mới với thông tin đã nhập và mặc định =====
    User u;
    u.username = username;                  // Gán username cho user
    u.passwordHash = hashPassword(pwd);     // Lưu mật khẩu dạng hash để bảo mật
    u.fullName = fullName;                  // Họ tên đầy đủ
    u.isAdmin = byAdmin;                    // Đánh dấu là admin nếu do admin tạo hộ
    u.isAutoGenerated = autoGen;            // Đánh dấu mật khẩu auto-generated
    u.wallet.id = "WAL" + to_string(time(nullptr)); // Sinh ID ví dựa theo thời gian hiện tại
    u.wallet.balance = 0;                   // Số dư ví khởi tạo
    u.wallet.poolBalance = 0;               // Số điểm pool-origin khởi tạo
    u.otp.clear();                          // Không có OTP pending
    u.pendingFullName.clear();              // Không có pending đổi tên
    u.pendingPasswordHash.clear();          // Không có pending đổi mật khẩu

    // ===== Tặng điểm thưởng cho user mới nếu còn trong rewardPool =====
    if (rewardPool >= 5) {
        u.wallet.balance += 5;              // Cộng 5 điểm vào ví user
        u.wallet.poolBalance += 5;          // Theo dõi riêng điểm thưởng nguồn gốc pool
        rewardPool -= 5;                    // Trừ 5 điểm từ rewardPool chung của hệ thống
        saveRewardPool(rewardPool);         // Lưu lại trạng thái mới của pool
    }

    users.push_back(u);     // Thêm user mới vào vector
    saveUsers(users);       // Lưu lại danh sách users ra file
    cout << "User '" << username << "' registered successfully.\n";
    return true;            // Báo thành công
}



// ====================
// Xóa user khỏi hệ thống
// ====================
// Trả về: true nếu xóa thành công, false nếu không tìm thấy user hoặc là admin
bool deleteUser(vector<User>& users, const string& username) {
    for (auto it = users.begin(); it != users.end(); ++it) {  // Duyệt từng user trong vector
        if (it->username == username) {       // Nếu tìm thấy user cần xóa
            if (it->isAdmin) {                // Không cho phép xóa tài khoản admin
                cout << "Cannot delete admin.\n";
                return false;
            }
            // Nếu user còn điểm pool, trả lại pool hệ thống
            if (it->wallet.poolBalance > 0) {
                rewardPool += it->wallet.poolBalance;
                saveRewardPool(rewardPool);   // Ghi lại pool mới sau khi cộng
            }
            users.erase(it);                  // Xóa user khỏi vector
            saveUsers(users);                 // Ghi lại file users sau khi xóa
            cout << "Deleted user \"" << username << "\".\n";
            return true;                      // Trả về true khi đã xóa thành công
        }
    }
    return false;                             // Không tìm thấy user để xóa
}

// ====================
// Yêu cầu nhập OTP xác nhận thao tác
// ====================
// Trả về true nếu nhập đúng OTP, false nếu sai
bool requireOTP(const string& username) {
    string otp = genOTP();                    // Sinh mã OTP ngẫu nhiên
    cout << "[OTP for " << username << ": " << otp << "]\n";  // Hiển thị OTP ra màn hình (DEMO)
    cout << "Enter OTP: ";
    string in; cin >> in;
    if (in != otp) {                          // Kiểm tra nhập OTP đúng không
        cout << "Invalid OTP.\n";
        return false;
    }
    return true;
}

// ==================================================
// Xóa block OTP đã xác nhận thành công khỏi file chờ
// ==================================================
// Khi user xác nhận OTP đổi tên/mật khẩu, xóa block liên quan khỏi pending_change.txt
void removePendingChange(const string& username, const string& otp) {
    ifstream fin("pending_change.txt");       // Mở file chờ xác nhận (mode read)
    if (!fin) return;                         // Nếu file không mở được thì thoát luôn
    ostringstream oss;                        // Chuỗi luồng để lưu lại các block không bị xóa
    string line, block;                       // Dòng đang đọc và block tích lũy
    bool found = false, inBlock = false;      // Cờ đã tìm ra block đúng chưa, có đang ở block cần không

    // Đọc từng dòng, nhóm thành các block với đầu là "Username:" và cuối là "-----------"
    while (getline(fin, line)) {
        if (line.find("Username: ") == 0) {   // Khi gặp user mới (bắt đầu block)
            if (!block.empty() && !found) oss << block; // Nếu chưa phải block cần xóa thì giữ lại
            block.clear();
            found = false;
            inBlock = false;
        }
        block += line + "\n";                 // Thêm dòng hiện tại vào block
        if (line == "Username: " + username) inBlock = true; // Đang trong block của user cần xóa
        if (inBlock && line == "OTP: " + otp) found = true;  // Nếu đúng OTP, đánh dấu sẽ xóa block này
        if (line == "-----------") {
            if (!found) oss << block;         // Nếu không phải block cần xóa thì giữ lại
            block.clear();
            found = false;
            inBlock = false;
        }
    }
    if (!block.empty() && !found) oss << block; // Nếu còn block cuối mà không bị xóa thì giữ lại
    fin.close();

    ofstream fout("pending_change.txt", ios::trunc); // Ghi đè lại file, chỉ giữ block không bị xóa
    fout << oss.str();
    fout.close();
}

// =============================================================
// Đăng nhập hệ thống, xác nhận OTP nếu user có pending thay đổi
// =============================================================
// Trả về: con trỏ User nếu đăng nhập thành công, nullptr nếu thất bại hoặc vừa xác nhận OTP (phải login lại)
User* login(vector<User>& users) {
    string username;
    cout << "Username: ";
    getline(cin, username);                    // Nhập username (cho phép dấu cách)
    if (username.empty()) getline(cin, username); // Nếu bị bỏ trống do nhập trước đó thì nhập lại
    User* u = findUser(users, username);
    if (!u) { cout << "User not found.\n"; return nullptr; }

    // Nếu user có pending change (đổi tên/mật khẩu), yêu cầu nhập OTP xác nhận trước khi vào hệ thống
    if (!u->isAdmin && !u->otp.empty() &&
        (!u->pendingFullName.empty() || !u->pendingPasswordHash.empty())) {

        cout << "Pending update detected!\n";
        if (!u->pendingFullName.empty())
            cout << "- Your full name will be changed to: " << u->pendingFullName << endl;
        if (!u->pendingPasswordHash.empty())
            cout << "- Your password will be changed (new password set by admin)" << endl;
        cout << "Your OTP is: " << u->otp << endl; // Báo cho user biết OTP
        cout << "Enter OTP to confirm these changes: ";
        string in; cin >> in;
        if (in == u->otp) {                      // Nếu nhập đúng OTP
            if (!u->pendingFullName.empty()) {
                u->fullName = u->pendingFullName;// Áp dụng thay đổi tên
                u->pendingFullName.clear();
            }
            if (!u->pendingPasswordHash.empty()) {
                u->passwordHash = stoull(u->pendingPasswordHash); // Áp dụng mật khẩu mới (hash)
                u->pendingPasswordHash.clear();
            }
            removePendingChange(u->username, u->otp); // Xóa block đã xác nhận khỏi file pending
            u->otp.clear();                          // Xóa OTP khỏi user
            saveUsers(users);                        // Lưu user vừa cập nhật
            cout << "Changes applied. Please login again.\n";
        }
        else {
            cout << "Invalid OTP. Changes not applied.\n";
        }
        return nullptr; // Đăng xuất sau khi xác nhận hoặc nhập sai OTP, phải đăng nhập lại
    }

    // Nếu không có pending change: đăng nhập bình thường bằng mật khẩu
    cout << "Password: ";
    string pwd = inputHiddenPassword();         // Nhập mật khẩu kiểu ẩn
    if (u->passwordHash != hashPassword(pwd)) { // So sánh hash của mật khẩu nhập với hash lưu trong user
        cout << "Login failed.\n";
        return nullptr;
    }

    // Nếu user có mật khẩu tự sinh, bắt buộc phải đổi mới
    if (u->isAutoGenerated) {
        cout << "\nYour password was auto-generated. You must change it now.\n";
        while (true) {
            cout << "New password: "; string np = inputHiddenPassword();
            cout << "Confirm: "; string cp = inputHiddenPassword();
            if (np != cp) cout << "Passwords do not match. Try again.\n";
            else if (np.empty()) cout << "Password cannot be empty.\n";
            else {
                u->passwordHash = hashPassword(np); // Lưu mật khẩu mới (đã hash)
                u->isAutoGenerated = false;
                saveUsers(users);                   // Lưu user cập nhật
                cout << "Password changed successfully.\n";
                break;
            }
        }
    }
    cout << "Welcome, " << u->fullName << (u->isAdmin ? " (Admin)" : "") << "!\n"; // Thông báo đăng nhập thành công
    cout << "\nPress Enter to main menu...";
    cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Chờ Enter trước khi chuyển sang menu chính
    return u;                                            // Đăng nhập thành công, trả về con trỏ user
}
