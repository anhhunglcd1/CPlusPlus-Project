#include "login_system.h"
#include <iostream>
#include <limits>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <cctype>
using namespace std;

// ----------------------
// Ghi log pending change
// ----------------------
// Ghi lại thay đổi cần xác nhận OTP vào file pending_change.txt (admin đổi hộ tên hoặc mật khẩu)
// Input: username - tên người dùng bị chỉnh, otp - mã OTP xác thực, type - loại thay đổi ("FullName" hoặc "Password")
void logPendingChange(const string& username, const string& otp, const string& type) {
    ofstream fout("pending_change.txt", ios::app); // Mở file để ghi tiếp (không xóa nội dung cũ)
    time_t now = time(nullptr); // Lấy thời gian hiện tại
    fout << "Username: " << username << "\n";
    fout << "OTP: " << otp << "\n";
    fout << "Change: " << type << "\n";
    fout << "Time: " << nowToString(now) << "\n"; // Ghi lại thời điểm thao tác
    fout << "-----------\n";
    fout.close();
}

// --------------------------
// Đặt lịch đổi tên (admin đổi hộ)
// --------------------------
// Sau khi chạy hàm này, user sẽ phải xác nhận OTP ở lần login tiếp theo
void scheduleFullNameChange(User* u, vector<User>& users) {
    cout << "Enter new full name: ";
    string nm; getline(cin, nm);            // Nhập tên mới từ bàn phím (có thể có dấu cách)
    u->pendingFullName = nm;                // Lưu tên mới vào trường pending
    if (u->otp.empty())                     // Nếu user chưa có OTP đang chờ thì tạo mới
        u->otp = genOTP();                  // Sinh OTP ngẫu nhiên
    saveUsers(users);                       // Lưu lại user (trạng thái pending)
    logPendingChange(u->username, u->otp, "FullName"); // Ghi log chờ xác nhận vào file log
    cout << "Change scheduled! User must confirm with OTP at next login.\n";
}

// ------------------------------
// Đặt lịch đổi mật khẩu (admin đổi hộ)
// ------------------------------
// Mật khẩu mới sẽ chỉ có hiệu lực sau khi user xác nhận OTP khi đăng nhập
void schedulePasswordChange(User* u, vector<User>& users) {
    cout << "Enter new password: ";
    string np = inputHiddenPassword(); // Nhập mật khẩu mới, ẩn ký tự nhập vào (dấu *)
    u->pendingPasswordHash = to_string(hashPassword(np)); // Hash mật khẩu rồi lưu vào trường pending
    if (u->otp.empty())    // Nếu chưa có OTP chờ thì sinh mới
        u->otp = genOTP();
    saveUsers(users);      // Lưu trạng thái pending
    logPendingChange(u->username, u->otp, "Password"); // Ghi log pending vào file log
    cout << "Change scheduled! User must confirm with OTP at next login.\n";
}

// ------------------------------
// Đổi mật khẩu (user tự đổi)
// ------------------------------
// Người dùng phải xác nhận OTP thật mới được đổi
// Sau khi đổi, không còn bị bắt buộc đổi mật khẩu nữa
void changePassword(User* u, vector<User>& users) {
    if (!requireOTP(u->username)) return;    // Bắt buộc xác nhận OTP để đổi mật khẩu
    cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Làm sạch buffer nhập
    cout << "New password: ";
    string np = inputHiddenPassword();       // Nhập mật khẩu mới (hiện dấu *)
    u->passwordHash = hashPassword(np);      // Hash mật khẩu và lưu lại
    u->isAutoGenerated = false;              // Không còn là auto-generated password nữa
    saveUsers(users);                        // Lưu lại user vào file
    cout << "Password changed successfully.\n";
}

// ------------------------------
// Đổi tên (user tự đổi)
// ------------------------------
void updateFullName(User* u, vector<User>& users) {
    if (!requireOTP(u->username)) return;    // Xác nhận OTP mới đổi được tên
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    cout << "New full name: ";
    string nm; getline(cin, nm);             // Nhập tên mới
    u->fullName = nm;                        // Lưu lại
    saveUsers(users);                        // Lưu user vào file
    cout << "Full name updated successfully.\n";
}

// ------------------------------
// Hiển thị thông tin cá nhân (Profile)
// ------------------------------
void viewProfile(User* u) {
    cout << "--- Profile ---\n"
        << "Username   : " << u->username << "\n"
        << "Full name  : " << u->fullName << "\n"
        << "Wallet ID  : " << u->wallet.id << "\n"
        << "Balance    : " << (u->isAdmin ? "Unlimited" : to_string(u->wallet.balance)) << "\n";
}

// ------------------------------
// Hiển thị lịch sử giao dịch của ví
// ------------------------------
void viewHistory(User* u) {
    cout << "--- Transaction History ---\n";
    for (auto& tx : u->wallet.history) {
        // In thời gian, ví gửi, ví nhận, số điểm giao dịch
        cout << nowToString(tx.timestamp) << " | "
            << tx.fromWallet << " -> " << tx.toWallet << " : " << tx.amount << "\n";
    }
}

// ===================== CHUYỂN ĐIỂM =======================
// Chuyển điểm từ user hiện tại sang user khác (qua wallet ID, không phân biệt hoa/thường)
// Có xác thực OTP trước khi chuyển
void transferPoints(User* u, vector<User>& users) {
    // Kiểm tra còn user nhận nào không (ngoài chính mình)
    bool hasRecipient = false;
    for (auto& x : users) {
        if (x.username != u->username) {
            hasRecipient = true;
            break;
        }
    }
    if (!hasRecipient) {
        cout << "No available recipients. Transfer aborted.\n";
        return;
    }
    // Nếu không phải admin, in ra số dư hiện tại
    if (!u->isAdmin) {
        cout << "\nYour current balance: " << u->wallet.balance << " points\n";
    }
    // Liệt kê tất cả user nhận có thể chọn (trừ chính mình)
    cout << "--- Available Recipients ---\n";
    for (auto& x : users) {
        if (x.username == u->username) continue;
        cout << " >  " << x.username
            << "  (Wallet ID: " << x.wallet.id << ")\n";
    }
    cout << "---------------------------\n";
    cout << "Destination wallet ID: ";
    string dest;
    cin >> dest;
    // Chuyển wallet ID nhập về chữ thường để tìm kiếm không phân biệt hoa/thường
    transform(dest.begin(), dest.end(), dest.begin(), ::tolower);

    User* v = nullptr;
    // Tìm user có wallet.id trùng (không phân biệt hoa/thường)
    for (auto& x : users) {
        string candidateId = x.wallet.id;
        transform(candidateId.begin(), candidateId.end(), candidateId.begin(), ::tolower);
        if (candidateId == dest) {
            v = &x;
            break;
        }
    }
    if (!v) {
        cout << "Wallet not found.\n";
        return;
    }
    cout << "Amount to transfer: ";
    int amt = 0;
    if (!(cin >> amt)) { // Kiểm tra nhập có phải số không
        cout << "Invalid input. Must be a number.\n";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        return;
    }
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    // Số điểm phải > 0
    if (amt <= 0) {
        cout << "Amount must be a positive number greater than 0.\n";
        return;
    }
    // Nếu là user thường thì phải kiểm tra số dư đủ không
    if (!u->isAdmin && u->wallet.balance < amt) {
        cout << "Insufficient balance.\n";
        return;
    }
    // Bắt buộc xác thực OTP trước khi chuyển
    if (!requireOTP(u->username)) return;

    // Tính toán phần điểm lấy từ pool (origin-point) và phần còn lại (non-pool)
    int availablePool = u->wallet.poolBalance;
    int fromPool = min(availablePool, amt);   // Lấy hết origin-point trước nếu đủ
    int fromNonPool = amt - fromPool;         // Số còn lại lấy từ điểm cộng thêm sau này
    if (!u->isAdmin) {
        u->wallet.balance -= amt;             // Trừ tổng số điểm khỏi ví người chuyển
    }
    // Trừ đúng phần lấy từ pool
    u->wallet.poolBalance -= fromPool;

    // Cộng toàn bộ điểm cho ví nhận, chỉ cộng phần origin-point vào poolBalance
    v->wallet.balance += amt;
    v->wallet.poolBalance += fromPool;

    // Ghi lịch sử giao dịch cho cả hai ví (cùng một bản ghi cho minh bạch)
    time_t now = time(nullptr);
    Transaction txA{ u->wallet.id, v->wallet.id, amt, (fromPool > 0), now }; // Giao dịch ở ví gửi
    Transaction txB{ u->wallet.id, v->wallet.id, amt, (fromPool > 0), now }; // Giao dịch ở ví nhận
    u->wallet.history.push_back(txA);
    v->wallet.history.push_back(txB);

    // Lưu mọi thay đổi ra file
    saveUsers(users);
    cout << "Transfer successful.\n";
}
